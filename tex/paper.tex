\documentclass{article}

\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{hyperref, listings, xcolor, float, natbib, amsmath}

\usepackage[nottoc]{tocbibind}
\usepackage[binary-units=true]{siunitx}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mycode}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mycode}

\title{Rust Safeness}
\author{Edoardo De Matteis}

\begin{document}

\maketitle
\tableofcontents

\clearpage 

\section{Introduzione}
Definiamo un'entità software \emph{memory-safe} quando non accede ad indirizzi di memoria fuori dal proprio address space né esegue istruzioni fuori dall'area assegnatale da compilatore e linker ~\cite{paper:def}, un linguaggio che garantisce la memory-safety dei suoi programmi è detto memory-safe.

\subsection{Configurazione della memoria}
A tempo di compilazione avviene l'allocazione statica della memoria sul \emph{call stack} che cresce verso il basso, l'allocazione dinamica invece avviene tramite l'\emph{heap}: una zona di memoria che cresce verso l'altro in cui è possibile allocare dati la cui dimensione non è nota a tempo di compilazione ~\cite{gollmann:computersecurity}. Questo approccio consolidato è adottato da vari sistemi operativi UNIX e UNIX-like oltre che da compilatori di linguaggi quali C, Rust, Java e C++; quali strutture dati vengano allocate in quale area della memoria dipende dal linguaggio, è prassi che sullo stack si allochino le chiamate a funzione, i tipi primitivi e puntatori mentre sull'heap compound types.

\section{Violazione della memory-safety}
Se in un linguaggio la gestione della memoria è lasciata al programmatore il linguaggio è generalmente unsafe (come C o C++), altri linguaggi quali Java o C\# risolvono questo problema nascondendo i puntatori al programmatore ed eseguendo automaticamente la gestione della memoria, obbligando il linguaggio ad eseguire i dovuti controlli. In Rust è possibile fare riferimento esplicito alla memoria tramite puntatori ma bisogna distinguere tra \emph{Safe Rust} e \emph{Unsafe Rust}, nel secondo è infatti presente l'aritmetica dei puntatori del C purché sia in un blocco \texttt{unsafe} (nel quale si possono usare anche funzioni e librerie scritte in C) mentre in Safe Rust esistono i raw pointer ma non è possibile dereferenziarli.  

\subsection{Politica di sicurezza} \label{sec:politica_di_sicurezza}
È molto difficile definire cosa sia la sicurezza in Rust anche solo per il fatto che non c'è una definizione precisa
\begin{center}
	\textit{"Unsafe operations are those that can potentially violate the memory-safety guarantees of Rust's static semantics."} ~\cite[14]{rust:reference} \\
	\textit{"There is no formal model of Rust's semantics for what is and is not allowed in unsafe code"} ~\cite[14.3]{rust:reference}
\end{center}
La definizione più consistente è che Safe Rust non causi \emph{undefined behavior}, purtroppo non si ha una definizione formale di undefined behavior bensì è una lista in continuo aggiornamento ~\cite[14.3]{rust:reference} ma è decisamente incompleta dato che non compaiono \emph{integer overflow} e \emph{double free} che invece sono considerati errori rispettivamente in ~\cite[3.2]{rust:language} e ~\cite[4.1]{rust:language}.

\subsubsection{Buffer Overflow}
Avviene quando in un buffer si possono inserire dati di dimensione maggiore della sua capacità sovrascrivendo così altre informazioni ~\cite{nist:800}. 
Un esempio esplicativo ed interessante di buffer overflow in C è nel listato \ref{lst:stackoverflowc} ~\cite[7.5]{stallings:os}: dato che gli array sono posizionati uno dopo l'altro (in ordine LIFO essendo dati allocati su uno stack) si riesce a leggere e scrivere su \texttt{str1} eludendo anche il controllo di uguaglianza, nel terzo caso è vero perché si confrontano solo i primi 8 caratteri. In Rust questa cosa non è possibile, si veda nel listato \ref{lst:bufofrs} come il linguaggio esegua dei \emph{boundary-check}, esattamente ciò che la funzione \texttt{gets} non fa. 

\lstinputlisting{../code/BufferOverflow/StackOverflow/StackAttack/stackattack.c}
\lstinputlisting[caption={Stack overflow in C}, label={lst:stackoverflowc}]{../code/BufferOverflow/StackOverflow/StackAttack/output/stackattack_c.txt}

\lstinputlisting{../code/BufferOverflow/bufof.rs}
\lstinputlisting[caption=Buffer overflow in Rust, label={lst:bufofrs}]{../code/BufferOverflow/output/bufof_rs.txt}

\subsubsection{Stack Overflow}
Quando si chiama una funzione si salva lo stack frame sul call stack e può capitare che chiamate ricorsive facciano entrare il programma in uno stato di non terminazione, Rust prima identifica staticamente la ricorsione infinita e poi segnala anche dinamicamente l'overflow. In C l'errore che si vede è dato dal sistema operativo (macOS Catalina 10.15.3) perché con questa ricorsione infinita si prova ad accedere ad un segmento  di memoria cui il programma non può.

\lstinputlisting{../code/BufferOverflow/StackOverflow/Recursion/recursion.c}
\lstinputlisting[caption={Stack overflow ricorsivo in C}, label={lst:recursionc}]{../code/BufferOverflow/StackOverflow/Recursion/output/recursion_c.txt}

\lstinputlisting{../code/BufferOverflow/StackOverflow/Recursion/recursion.rs}
\lstinputlisting[caption={Stack overflow ricorsivo in Rust}, label={lst:recursionrs}]{../code/BufferOverflow/StackOverflow/Recursion/output/recursion_rs.txt}

\subsubsection{Integer Overflow}
In qualsiasi macchina non astratta si ha memoria finita ed è rappresentabile solo un insieme finito di numeri, quando un valore è troppo grande (o piccolo) per essere rappresentato si ha un overflow. Sono due gli approcci principali per risolvere un integer overflow, ognuno basato su un'aritmetica differente:
\begin{itemize}
    \item \textbf{Modular arithmetic}. Si applica un wrapping ad ogni numero in overflow, dato il valore $n$ e una memoria a $m$ bit si memorizza $w = n \mod m$.
    \item \textbf{Saturation arithmetic}. Dati $min$ e $max$ - rispettivamente il numero più grande e più piccolo rappresentabile - e un numero $n$ in memoria viene salvato
    \begin{equation*}
        c = \begin{cases}
            max & n > max \\
            min & n < min \\
            n  & \text{altrimenti} \\
        \end{cases}
    \end{equation*}
\end{itemize}

L'integer overflow ha in passato causato problemi molto seri: durante il volo inaugurale del lanciatore Ariane 5 un integer overflow dovuto ad una conversione in intero a 16 bit di un float a 64 bit ha causato una reazione a catena per cui il razzo ha virato orizzontalmente distruggendosi poco dopo il lancio, il codice scritto in Ada non prevedeva controlli di overflow in quanto esplicitamente richiesto dai progettisti per motivi di efficienza. Similmente in Rust compilando in \textit{debug} mode si eseguono dei controlli dinamici per l'overflow \ref{lst:integeroverflowrs}, contrariamente al C che applica direttamente wrapping. \\
Differenti linguaggi adottano differenti approcci per limitare integer overflow, se si può prevedere il valore massimo possibile in un programma allora è in generale facile evitare overflow; in caso contrario si possono utilizzare metodi dinamici che sfruttano eccezioni \ref{lst:integeroverflowrs}. 

\lstinputlisting{../code/IntegerOverflow/intof.rs}
\lstinputlisting[caption={Integer overflow in Rust}, label={lst:integeroverflowrs}]{../code/IntegerOverflow/output/intof_rs.txt}

Nel listato \ref{lst:integeroverflowc} si prende un intero come primo argomento e una stringa - idealmente di lunghezza pari al primo argomento - come secondo. Il problema sorge nella conversione da integer a short, inserendo come primo argomento 65536 ($2^{16}$ che non è rappresentabile con i soli 16 bit di uno short) si causa un buffer overflow combinandone la pericolosità con la difficoltà di rivelamento dell'integer overflow.

\lstinputlisting{../code/IntegerOverflow/width1.c}
\lstinputlisting[caption={Integer overflow in C}, label={lst:integeroverflowc}]{../code/IntegerOverflow/output/width1_c.txt}

\subsubsection{Double-Free} 
Si ha un \textit{double free error} ~\cite[10.4.4]{gollmann:computersecurity} quando si prova a liberare più volte la stessa zona di memoria, in Rust non è possibile grazie all'\textit{ownership} che impedisce ad un'area di memoria di esser puntata da più di un puntatore, nel codice in \ref{lst:doublefree_rs} si può vedere come \texttt{s1} perda validità dopo aver trasferito a \texttt{s2}l'ownership della stringa cui puntava.

\lstinputlisting{../code/DoubleFree/doublefree.rs}
\lstinputlisting[caption={Ownership}, label={lst:doublefree_rs}]{../code/DoubleFree/output/doublefree_rs.txt}

In C invece si può osservare il codice nel listato \ref{lst:doublefree_c}: si immagini di avere un servizio ad iscrizione salvando ogni utente tramite una struct \texttt{User}: Guido libera la propria memoria che, disponibile, potrà memorizzare \texttt{Luisa} che si è appena iscritta. Il puntatore \texttt{Guido} però ora punta all'account di Luisa e con \texttt{free(Guido)} proprio l'account di Luisa viene eliminato con il risultato che non solo Luisa non ha più un account ma a quello di Carla possono accedere sia Guido che Luisa.

\lstinputlisting{../code/DoubleFree/doublefree.c}
\lstinputlisting[caption={Ownership}, label={lst:doublefree_c}]{../code/DoubleFree/output/doublefree_c.txt}

Il puntatore \texttt{Guido} è anche un \textit{dangling pointer}.

\subsubsection{Dangling References}
Quando un oggetto viene eliminato ma il suo puntatore no si ha un \textit{dangling pointer} che permettere di accedere a memoria cui non dovrebbe. \\
Immaginiamo ora che per vendicarsi Luisa abbia scritto un semplice sistema di messaggistica per leggere la corrispondenza di Guido, la procedura \texttt{send\_message} crea un puntatore di tipo \texttt{Message} che ha scope solo ed esclusivamente dentro \texttt{send\_message} ma facendo riferimento esplicito a quella locazione Luisa riesce a leggere il messaggio di Guido anche dopo che questo non esiste più. Nel listato \ref{lst:dangrefc} l'indirizzo viene stampato a schermo e inserito dall'utente (indicato da $>$) per semplicità, lo si può rendere in modo più esplicito mantenendo una variabile per il puntatore, sia essa \texttt{mess} stessa o una ad hoc passata come argomento alla funzione.

\lstinputlisting{../code/DanglingReference/dangref.c}
\lstinputlisting[caption={Dangling pointer in C}, label={lst:dangrefc}]{../code/DanglingReference/output/dangref_c.txt}

In Rust non possiamo usare i puntatori perché l'ownership ci obbliga ad avere un puntatore solo e una volta disabilitato non possiamo più accedere a quell'area di memoria né si può leggere la locazione perché non è permesso il raw dereferencing; esistonono però le reference ~\cite[4.2]{rust:language} che permettono di prendere in prestito (\textit{borrowing}) una variabile senza esserne proprietari, nel codice in \ref{lst:dangrefrs} \texttt{s} nella riga 5 è quindi una \textit{shallow copy} di \texttt{s2}. Come nell'\textit{ownership} però anche il \textit{borrowing} perde validità oltre lo scope.

\lstinputlisting{../code/DanglingReference/dangref.rs}
\lstinputlisting[caption={Dangling reference in Rust}, label={lst:dangrefrs}]{../code/DanglingReference/output/dangref_rs.txt}

\subsection{Type Safety}
Durante l'esecuzione di un programma si può incorrere in due tipi di errori: \textit{trapped} e \textit{untrapped}, i primi sono facilmente riconoscibili dato che provocano il fallimento dell'esecuzione di un programma, i secondi sono molto più difficili da individuare perché non interrompono il programma. Un linguaggio in cui nessun programma legale genera errori trapped né untrapped si dice \textit{sound}, solo untrapped invece si dice \textit{safe} (un linguaggio sound è necessariamente safe) ~\cite{cencia:dispense}. Una definizione simile è quella di Milner per cui \textit{well-type programs cannot “go wrong”} ~\cite{milner:type_polymorphism}, con programmi che si "comportano male" si possono intendere programmi non sound o che generano undefined behaviour (sezione \ref{sec:politica_di_sicurezza}). 

\subsubsection{Type Confusion} \label{sec:type_confusion}
Nel listato \ref{lst:lilliputc} si alloca un array di short ($\SI{2}{\byte} $) staticamente, andrà quindi sullo stack e considerando che il computer su cui ho eseguito il programma monta un processore Intel - little endian- si ha la seguente rappresentazione in memoria

\begin{table}[H]
	\label{fig:mem_type_stack}
	\centering
	\begin{tabular}{|c|c|}
		\hline
		\texttt{1} & \texttt{1000000000000000} \\
		\hline 
		\texttt{0} & \texttt{0000000000000000} \\
		\hline
	\end{tabular}
\end{table}

il puntatore \texttt{p} punta al primo elemento ma essendo \texttt{int} legge $\SI{4}{\byte}$  
\[
\texttt{00000000000000001000000000000000} \\
\]
che in decimale equivale a $ 2^{16} = 65536 $.

\lstinputlisting{../code/TypeSafety/Lilliput/lilliput.c}
\lstinputlisting[caption={Type confusion in C}, label={lst:lilliputc}]{../code/TypeSafety/Lilliput/output/lilliput_c.txt}

In Rust non si può proprio puntare ad una variabile con un tipo differente da quello della variabile stessa.

\lstinputlisting{../code/TypeSafety/Lilliput/lilliput.rs}
\lstinputlisting[caption={Type confusion in Rust}, label={lst:lilliputrs}]{../code/TypeSafety/Lilliput/output/lilliput_rs.txt}

\section{Note al professore}
Nella sezione \ref{sec:type_confusion} non sono riuscito a trovare esempi significativi di type confusion in C proprio grazie alla sua semplicità e assenza di classi quindi sembra più un'opacità semantica come ha detto lei.

\clearpage
%\bibliographystyle{unsrtnat}
\bibliographystyle{plain}
\bibliography{paper}{}

\end{document}
