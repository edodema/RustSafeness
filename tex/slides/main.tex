\documentclass{beamer}
\usetheme{Szeged}
\usecolortheme{beaver}

\usepackage[utf8]{inputenc}

\usepackage{listings, float, graphicx, lipsum, parallel, verbatim, mathtools, amssymb}
%\usepackage[dvipsnames]{xcolor}

% colors
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{deepskyblue}{rgb}{0.0, 0.75, 1.0}
\definecolor{persianpink}{rgb}{0.97, 0.5, 0.75}

% Rust syntax highlighting
\lstdefinelanguage{Rust}{
    keywords={},
    otherkeywords={% Operators
        0x, 0o, 0b,
        i8, i16, i32, i64, i32, i128, isize, 
        u8, i16, u32, u64, u32, u128, usize, 
        f8, f16, f32, f64, f32, f128, fsize
    },
    keywords = [2]{fn, if, in, for, let, match, struct, unsafe, while, union},
    keywords = [3]{as, const, move, mut, true, false},
    keywordstyle=\color{codepurple},
    keywordstyle=[2]\color{deepskyblue},
    keywordstyle=[3]\color{persianpink},
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    commentstyle=\color{codegreen}\ttfamily,
    stringstyle=\color{orange}\ttfamily,
    morestring=[b]"
}

\lstdefinestyle{mycode}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{deepskyblue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{orange},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mycode}

% command for inline code
\newcommand{\textcode}[1]{\colorbox{backcolour}{\texttt{#1}}}

\title{Proprietà di sicurezza nel linguaggio Rust}
\author{Edoardo De Matteis}
\institute[Sapienza Università di Roma Dipartimento di Informatica]{\includegraphics[scale=0.3]{images/logo_sapienza_neg.png}}
\date{Dicembre 2020}
\setbeamertemplate{navigation symbols}{}

\begin{document}

\frame{\titlepage}

%\begin{frame}
%    \frametitle{Problema attuale}
%    Il 98\% dei sistemi ICT sono integrati e richiedono un controllo a basso livello delle risorse e negli anni a venire questa tendenza non diminuirà. 
%    Il linguaggio più usato è C ma Rust si propone come linguaggio sicuro per embedded system.
%\end{frame}

%\begin{frame}
%\frametitle{Principi di sicurezza}
%Si indica con \textbf{soggetto} qualsiasi entità che richieda di accedere ad un \textbf{oggetto}. 
%La \textbf{trusted computed base (TCB)} è la totalità delle componenti che vanno a definire la sicurezza di un sistema 
%\end{frame}

\begin{frame}
    \frametitle{Principi di sicurezza}

    \begin{itemize}
        \item Least privilege.
        \item Fail-safe default.
        \item Economy of mechanisms.
        \item Complete mediation.
        \item Open design.
        \item Separation of privilege.
        \item Least common mechanism.
        \item Psychological acceptability.
    \end{itemize}
\end{frame}

%\begin{frame}
%    \frametitle{Rust}
%    Rust è un linguaggio di programmazione focalizzato sulla velocità d'esecuzione e sulla sicurezza dei suoi programmi tramite \textbf{ownership}, \textbf{borrowing} e \textbf{lifetime}.
%\end{frame}

%\begin{frame}
%    \frametitle{Ownership}
%    L'ownership rappresenta il possesso di un \textbf{right value} da parte di un \textbf{left value}, ad un variabile corrisponde esattamente un valore e ad un valore una sola variabile. 
%    Un assegnamento invalida l'accesso da parte della variabile precedente, se presente.  

%    L'ownership permette di avere una gestione automatica della memoria senza garbage collector.
%\end{frame}

\begin{frame}
    \frametitle{Ownership}
    \lstinputlisting[language=Rust, basicstyle=\fontsize{8}{9}\selectfont]{../../code/Ownership/own.rs}
\end{frame}

%\begin{frame}
%    \frametitle{Borrowing}
%    Il borrowing permette di creare molteplici riferimenti in lettura ad un dato, tramite il modificatore \textcode{mut} è possibile definire un unico riferimento modificabile.
%    Il \textbf{borrow checker} garantisce a tempo di compilazione tramite i \textbf{lifetime} che un oggetto non venga distrutto se ne esistono dei riferimenti.
%\end{frame}

\begin{frame}
    \frametitle{Borrowing}
    \lstinputlisting[language=Rust, basicstyle=\fontsize{8}{9}\selectfont]{../../code/Borrowing/borr.rs}
\end{frame}

%\begin{frame}
%    \frametitle{Lifetime}
%    Un lifetime è una regione di codice nella quale ogni riferimento deve essere valido, al momento della definizione di una variabile le viene associato un lifetime che verrà poi distrutto con la distruzione della variabile.
    
%    Ad un lifetime possono essere associati più scope e ad uno scope possono essere associati più lifetime.
%\end{frame}

\begin{frame}
    \frametitle{Lifetime}
    %In Rust valgono le tre seguenti regole assiomatiche:
    \begin{itemize}
        \item \textbf{Association}. Lo scope di un riferimento è sottoinsieme del suo lifetime. 
        \item \textbf{Reference}. Il lifetime associato ad un riferimento è sottoinsieme dello scope dell'oggetto cui fa riferimento.  
        \item \textbf{Assignment}. Il lifetime associato ad un riferimento è sottoinsieme del lifetime dell'oggetto cui fa riferimento.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Sicurezza di un linguaggio}
    La \textbf{TCB} può essere scomposta in: 
    \begin{itemize}
        \item Access control.
        \item Information flow.
    \end{itemize}
    %Il sistema operativo esegue questi controlli e vengono bloccati alcuni programmi che in C sono legali. 
    %Internet ha reso semplice la condivisione dello stesso codice su macchine con sistemi operativi differenti, per questo la sicurezza è stata implementata direttamente nel linguaggio, come in Rust.
\end{frame}

\begin{frame}
    \frametitle{Security policy}
    In Rust consideriamo un programma sicuro se:
    \begin{itemize}
        \item Non presenta codice \textcode{unsafe}.
        \item Non genera \textbf{undefined behavior}.
        \item Non è possibile dereferenziare un \textbf{raw pointer}.
        \item Non è possibile accedere al campo di un'\textcode{union} se non per l'inizializzazione.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Sicurezza in Rust}
    \begin{enumerate}
        \item I meccanismi di sicurezza in Rust sono modellati sulla \textbf{logica lineare}.
        \item La sicurezza in Rust è divisa concettualmente in  \textbf{memory safety} e \textbf{type safety}.
    \end{enumerate} 
\end{frame}

\begin{frame}
    \frametitle{Sistema di tipi substrutturale}
    %Un sistema di tipi è detto \textbf{substrutturale} quando almeno una delle tre regole \textbf{strutturali} non è valida:
    \begin{itemize}
        \item \textbf{Exchange}. L'ordine degli elementi in un'ipotesi o conclusione è irrilevante. 
        \item \textbf{Weakening}. Ipotesi e conclusione possono essere estese con affermazioni superflue. 
        \item \textbf{Contraction}. In ipotesi e conclusione è possibile unificare due elementi unificabili. 
    \end{itemize} 
\end{frame}

\begin{frame}
    \frametitle{Sistema di tipi lineare}
    %Un sistema si dice lineare quando è valida solo exchange, valgono due invarianti:
    \begin{itemize}
        \item Le variabili lineari sono usate esattamente una volta.
        \item Espressioni meno restrittive non possono contenere espressioni più restrittive.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Memory Safety}
    %Si parla di memory safety quando in un programma nessuna entità esce fuori dal proprio \textbf{address space}. 
    %È definito dall'allocazione, ne considereremo tre tipi:
    \begin{itemize}
        \item Allocazione statica.
        \item Allocazione dinamica.
        \item Allocazione automatica.
    \end{itemize}    
\end{frame}

\begin{frame}
    \frametitle{Buffer overflow}
    \lstinputlisting[language=c, basicstyle=\fontsize{8}{9}\selectfont]{../../code/BufferOverflow/bufof.c}
    \lstinputlisting[language=Rust, basicstyle=\fontsize{8}{9}\selectfont]{../../code/BufferOverflow/bufof.rs}    
\end{frame}

\begin{frame}
    \frametitle{Integer overflow}
    %Gli approcci principali adoperati di fronte ad un integer overflow sono i seguenti:
    \begin{itemize}
        \item Modular arithmetic. \[ w = n \mod m \]
        \item Saturation arithmetic. 
        \[ 
            c = \begin{cases}
            max & n > max \\
            min & n < min \\
            n  & \text{altrimenti} \\
        \end{cases} 
        \]
    \end{itemize}
\end{frame}

%\begin{frame}
%    \frametitle{Double free}
%    Quando si libera due volte la stessa memoria si incorre in un double free error e in C è possibile avere due puntatori che puntano alla stessa locazione.

%    In Rust l'ownership ci impedisce a priori di avere due puntatori sullo stesso dato. 
%\end{frame}

\begin{frame}
    \frametitle{Double free}
    \lstinputlisting[language=c, basicstyle=\fontsize{8}{9}\selectfont]{../../code/DoubleFree/double_simple.c}
\end{frame}

%\begin{frame}
%    \frametitle{Dangling reference}
%    Quando un oggetto viene eliminato senza liberare i suoi puntatori si ha un dangling pointer che può essere usato per accedere a memoria cui non si dovrebbe. 
    
%    Rust tramite il borrow checker impedisce di avere puntatori dopo la distruzione di un oggetto e in ogni caso non è possibile dereferenziare un raw pointer.
%\end{frame}

\begin{frame}
    \frametitle{Dangling reference}
    \lstinputlisting[language=Rust, basicstyle=\fontsize{8}{9}\selectfont]{../../code/Lifetime/life_1_1.rs}
    \lstinputlisting[language=Rust, basicstyle=\fontsize{8}{9}\selectfont]{../../code/Lifetime/life_1_2.rs}
\end{frame}

\begin{frame}
    \frametitle{Type safety}
    Gli errori si dividono in:
    \begin{itemize}
        \item \textbf{trapped}
        \item \textbf{untrapped}
    \end{itemize}
    Un programma \textbf{ben tipato} può essere:
    \begin{itemize}
        \item \textbf{Sound}. Non viene generato alcun errore.
        \item \textbf{Safe}. Non vengono generati errori untrapped.
    \end{itemize}
\end{frame}

%\begin{frame}
%    \frametitle{Type casting}
%    Una conversione di tipo può essere esplicita o implicita (\textbf{coercion}), tipicamente i linguaggi con type checking forte hanno pochi casting impliciti e quelli con type checking debole ne hanno molti.
%    Il casting implicito può causare undefined behaviour e per questo in Rust non è presente. 
%\end{frame}

\begin{frame}
    \frametitle{Type casting}
    \lstinputlisting[language=c]{../../code/TypeConversion/coercion.c}
    \lstinputlisting[language=Rust]{../../code/TypeConversion/coercion.rs}
\end{frame}

%\begin{frame}
%    \frametitle{Type initialization}
%    In C una variabile non inizializzata assume il valore contenuto nel suo address space, in altri linguaggi si usa un valore speciale \texttt{NULL}.
%    In \textit{GCC} un puntatore a \texttt{NULL} punta alla locazione 0 che è però riservata, per questo in Rust non si ha il tipo polimorfo \textcode{Option<T>} che può assumere \textcode{Some<T>} o \textcode{None}.

%    \lstinputlisting[language=Rust, basicstyle=\fontsize{8}{9}\selectfont, lastline=6]{../../code/NullPointer/null.rs}
%\end{frame}

\begin{frame}
    \frametitle{Type initialization}
    \lstinputlisting[language=c]{../../code/NullPointer/null.c}
    \lstinputlisting[language=Rust, basicstyle=\fontsize{8}{9}\selectfont, lastline=6]{../../code/NullPointer/null.rs}
\end{frame}

%\begin{frame}
%    \frametitle{Immutability}
%    In Rust è possibile definire sia delle costanti tramite la parola chiave \textcode{const} che delle variabili, di default immutabili.

%    Anche in C esistono le costanti ma è possibile modificarne il valore dereferenziandone un puntatore all'interno di programmi concorrenti. 
%    Un programma del genere di norma viene interrotto dal sistema operativo.
%\end{frame}

\begin{frame}
    \frametitle{Immutability}
    \begin{columns}
        \begin{column}{0.5\textwidth}
            \textbf{Variabili}
            \begin{itemize}
                \item Si dichiarano con \textcode{let}.
                \item Possono essere modificate.
                \item Lifetime generico.
            \end{itemize}
        \end{column}

        \begin{column}{0.5\textwidth}
            \textbf{Costanti}
            \begin{itemize}
                \item Si dichiarano con \textcode{const}.
                \item Immutabili.
                \item Lifetime \textcode{'static}.
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}
    \frametitle{}
    \centering \huge
    \emph{Grazie}
\end{frame}


\end{document}

