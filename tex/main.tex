\documentclass[Lau,binding=0.6cm]{sapthesis}

\usepackage{microtype}
\usepackage[english, italian]{babel}
\usepackage[utf8]{inputenx}

\usepackage{hyperref}
\hypersetup{pdftitle={Proprietà di sicurezza nel linguaggio Rust},pdfauthor={Edoardo De Matteis}}

\usepackage{listings, float, graphicx, lipsum, cleveref, parallel, verbatim, mathtools, ebproof, comment}
\usepackage{amssymb, pifont}
\usepackage[square, sort, comma, numbers]{natbib}
\usepackage[dvipsnames]{xcolor}
\usepackage[nottoc]{tocbibind}
\usepackage[most]{tcolorbox}
\usepackage[binary-units=true]{siunitx}
\usepackage[autostyle=true]{csquotes}

% theorem box
\newtcbtheorem[number within=chapter]{Definizione}{}{
    enhanced,
    sharp corners,
    attach boxed title to top left={
        xshift=-1mm,
        yshift=-5mm,
        yshifttext=-1mm
    },
    top=1.5em,
    colback=white,
    colframe=white!50!black, %rendere solo bianco
    fonttitle=\bfseries,
    boxed title style={
        sharp corners,
        size=small,
        colback=white!50!black,
        colframe=white!50!black,
    } 
}{def}

\newenvironment{myDefinition}[2]{ \begin{Definizione}[adjusted title=#1]{}{#2}
    \textbf{Definizione \thetcbcounter.} }{\end{Definizione}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{}



\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinelanguage{Rust}{
  keywords={},
  otherkeywords={% Operators
    0x, 0o, 0b,
    i8, i16, i32, i64, i32, i128, isize, 
    u8, i16, u32, u64, u32, u128, usize, 
    f8, f16, f32, f64, f32, f128, fsize
  },
  keywords = [2]{fn, if, in, for, let, match, struct, unsafe, while, union},
  keywords = [3]{as, const, move, mut, true, false},
  keywordstyle=\color{codepurple},
  keywordstyle=[2]\color{MidnightBlue},
  keywordstyle=[3]\color{Rhodamine},
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{codegreen}\ttfamily,
  stringstyle=\color{orange}\ttfamily,
  morestring=[b]"
  }

\lstdefinestyle{mycode}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{MidnightBlue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{orange},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mycode}

% command for inline code
\newcommand{\textcode}[1]{\colorbox{backcolour}{\texttt{#1}}}

% checkmark and x mark
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

% Commands for the titlepage
\title{Proprietà di sicurezza nel linguaggio Rust}
\author{Edoardo De Matteis}
\IDnumber{1746561}
\course{Informatica}
\courseorganizer{Facoltà di Ingegneria dell'informazione, informatica e statistica}
\AcademicYear{2019/2020}
\copyyear{2020}
\advisor{Pietro Cenciarelli}
%\advisor{Dr. Nome Cognome}
%\coadvisor{Dr. Nome Cognome}
\authoremail{edoardodematteis@icloud.com}

%\examdate{16 April 2013}
%\examiner{Prof. Nome Cognome}
%\examiner{Prof. Nome Cognome}
%\examiner{Dr. Nome Cognome}
\versiondate{\today}

\begin{document}

\frontmatter

\maketitle

%\dedication{Dedicato a\\ Donald Knuth}

%\begin{abstract}
%\end{abstract}

%\begin{acknowledgments}
%\end{acknowledgments}

\tableofcontents

% Do not use the starred version of the chapter command!

\mainmatter

\chapter{Introduzione}
Rust è un linguaggio di programmazione focalizzato sulla velocità e sulla sicurezza dei suoi programmi.
L'interesse per Rust è in costante crescita e sempre più sviluppatori hanno intenzione di adottarlo per la creazione di nuovo software, come nel caso del sistema operativo Redox ~\cite{redox}, o per il porting di quello già esistente, come nel caso del browser Tor ~\cite{tor}.
La semantica del linguaggio definisce delle regole che impediscono la scrittura di programmi non sicuri, tendenzialmente i bug nascono dalla distrazione del programmatore e Rust tramite dei semplici accorgimenti riduce notevolmente la possibilità di scriverne, ad esempio le variabili sono modificabili solo quando esplicitamente richiesto.
Tale scelta rispetta il \textbf{principle of least privilege}.


Si definisce \textbf{soggetto} una qualsiasi entità attiva in un sistema e i soggetti accedono agli \textbf{oggetti}, nello sviluppo di sistemi sicuri ci si attiene a dei principi ma non è sempre possibile rispettarli tutti, alle volte vanno in contrasto tra loro e non è sempre facile individuare come un sistema si ponga rispetto ad alcuni di essi ~\cite{gollmann:computersecurity}:

\begin{itemize}
	\item \textbf{Least privilege.} Ad un soggetto è garantito l'insieme minimale di privilegi necessari per un dato compito.
	\item \textbf{Fail-safe default.} Ad un soggetto è consentito l'accesso ad una risorsa solo se esplicitamente autorizzato.
	\item \textbf{Economy of mechanisms.} I meccanismi di sicurezza devono essere semplici, quando si hanno poche righe di codice è più facile fare manutenzione \footnote{Equivale al più generale K.I.S.S. \textit{Keep it simple, stupid}.}.
	\item \textbf{Complete mediation.} Ogni accesso ad un oggetto deve essere verificato, solitamente una volta e prima dell'accesso effettivo.
	\item \textbf{Open design.} La sicurezza di un meccanismo non dipende dalla sua segretezza, il codice non deve essere necessariamente pubblico ma la \textit{security by obscurity} non dà alcuna garanzia.
		Il principio di open design non si applica ad informazioni che devono essere segrete quali chiavi crittografiche o d'accesso, alla security by obscurity si oppone la \textbf{security by design}.
	\item \textbf{Separation of privilege.} Un sistema non deve garantire i permessi basandosi solo su una singola condizione.
	\item \textbf{Least common mechanism.} I meccanismi usati per accedere alle risorse non dovrebbero essere condivisi, più una risorsa è condivisa in un insieme di soggetti più è facile che venga sfruttata per fini non sicuri.
	\item \textbf{Psychological acceptability.} I meccanismi di sicurezza non devono rendere l'accesso alle risorse più difficile di quanto non sarebbe senza.
\end{itemize}

Con \textbf{Trusted computing base (TCB)} si intende la totalità delle componenti che vanno a definire la sicurezza di un sistema, in concordanza con i principio di economy of mechanisms è desiderabile che la TCB sia il più contenuta possibile.
Rust regola l'accesso in conformità a questi principi tramite \textbf{ownership} e \textbf{borrowing}, sono meccanismi semplici che però richiedono un maggiore impegno da parte del programmatore, come si può vedere rispettare un principio ne viola un altro.

Il principale problema di Rust è la sua curva d'apprendimento, la stragrande maggioranza dei programmatori ha più familiarità con i linguaggi imperativi e Rust per quanto condivida una sintassi simile al C è molto influenzato da linguaggi funzionali come ML e Haskell. 
Per esempio Rust ne eredita il \textcode{let} e quasi ogni parte di una funzione è un'espressione ~\cite[1309-1573]{rust:syntax}, nel listato \ref{lst:funrs_if} si può vedere come una condizionale sia un'espressione, così facendo si elimina la necessità dell'operatore ternario \textcode{a ? b : c}.
Anche il costrutto \textcode{match} deriva dai linguaggi funzionali, si può vedere nel listato \ref{lst:funrs_match} e si può notare anche come non sia necessario specificare un valore di ritorno, omettendo il tipico \textcode{;} si ha un return automatico come in LISP.

\lstinputlisting[language=Rust]{../code/Functional/if.rs}
\lstinputlisting[caption={In Rust anche l'\textcode{if} è un'espressione.}, label={lst:funrs_if}, numbers=none]{../code/Functional/output/ifrs.txt}

\lstinputlisting[language=Rust]{../code/Functional/match.rs}
\lstinputlisting[caption={Match in Rust.}, label={lst:funrs_match}, numbers=none]{../code/Functional/output/matchrs.txt}

L'ownership rappresenta il possesso di un \textbf{right value} da parte di un \textbf{left value} e al momento dell'inizializzazione di un oggetto la sua variabile, se presente, è l'unico owner e un assegnamento ad una seconda variabile fa passare il possesso dalla prima alla seconda: in qualsiasi momento quindi può esserci solo un possessore per ogni oggetto. 
Un owner viene invalidato con la sua distruzione quando esce dal proprio scope, bisogna porre particolare attenzione in questo caso dato che le chiamate di funzioni possono invalidare le variabili passate come argomento: il possesso passa alla nuova variabile nel corpo della funzione e una volta terminato il suo scope non sarà più possibile accedere all'oggetto con la variabile precedente - si può avere massimo un owner per volta - né con la nuova poiché ormai si è fuori dal suo scope (listato \ref{lst:ownership}). 

\lstinputlisting[language=Rust,caption={Ownership}, label={lst:ownership}]{../code/Ownership/own.rs}

L'ownership è fondamentale per garantire una gestione automatica e sicura della memoria senza \textbf{garbage collector} ma non è sempre desiderabile prendere possesso di un oggetto, in questi casi si ricorre al borrowing.

Tramite il borrowing infatti si possono creare molteplici  riferimenti ~\cite[4.2]{rust:language} ad un dato purché in sola lettura, con il modificatore \textcode{mut} è possibile rendere il riferimento modificabile a patto che in qualsiasi momento per qualsiasi variabile ve ne sia al più uno (listato \ref{lst:borrowing}).
Un modulo chiamato \textbf{borrow checker} garantisce a tempo di compilazione che finché esistono dei riferimenti ad un oggetto non sarà possibile distruggere l'oggetto in questione.

\lstinputlisting[language=Rust,caption={Borrowing}, label={lst:borrowing}]{../code/Borrowing/borr.rs}

Per eseguire questa verifica si fa uso dei \textbf{lifetime} i quali garantiscono che ogni riferimento sia valido, il lifetime di una variabile inizia quando questa viene creata e termina quando viene distrutta.
Il borrowing simula una \textbf{call by reference}, come in C infatti Rust presenta solo \textbf{call by value}.
Quando possibile il compilatore inferisce i lifetime automaticamente, in caso contrario è necessario gestirli manualmente.

I lifetime sono delle regioni di codice nella quale ogni riferimento deve essere valido ~\cite[3.3]{rust:rustonomicon} ma è facile confondere scope e lifetime, negli esempi più semplici coincidono ma i secondi esprimono relazioni tra scope: un lifetime può essere associato a più scope e uno scope può avere associati più lifetime. 

Questi controlli evitano la presenza di \textbf{side effect}, un programma ne presenta quando contiene almeno un'operazione che modifica lo stato di una o più variabili non presenti nel suo ambiente locale. 
Non sono necessariamente negativi, variabili globali e processi concorrenti acquistano la loro forza proprio da questi effetti collaterali.

I controlli di ownership e borrowing sono eseguiti staticamente rendendo l'esecuzione del programma molto più rapida.


\section{Il problema del C}
Il linguaggio di programmazione C è stato sviluppato nel 1978 e ad oggi è ancora uno dei più popolari ~\cite{tiobe:index} ~\cite{pypl:index}, ciò è dovuto al fatto che circa il 98\% ~\cite{real_men_program_in_c} dei sistemi informatici sul mercato siano sistemi integrati che richiedono un basso overhead e C risponde a questa esigenza tramite una gestione manuale della memoria, l'esecuzione dei programmi consuma quindi meno risorse ma si richiede un maggiore impegno da parte del programmatore, è infatti suo compito allocare memoria adeguatamente e successivamente liberarla. 
Rimettendo totalmente al programmatore la gestione della memoria C permette di scrivere programmi non sicuri, esistono linguaggi come Java considerati sicuri che gestiscono automaticamente la memoria tramite \textbf{garbage collection} al prezzo di un maggiore overhead, sono quindi poco adatti alla scrittura di codice per embedded systems.
La garbage collection è una delle tecniche di gestione automatica della memoria più usate nei linguaggi di programmazione: tramite il garbage collector si tiene traccia di ogni allocazione e le zone di memoria non più necessarie vengono periodicamente liberate e rese nuovamente disponibili. 
La garbage collection ha il vantaggio di esonerare il programmatore dal dover gestire la memoria per potersi concentrare sulla logica del programma e la sua leggibilità, si evitano inoltre vulnerabilità quali \textbf{double free} o \textbf{dangling pointer} (rispettivamente sezioni \ref{sec:double_free} e \ref{sec:dangling_reference}). 
Con la garbage collection l'esecuzione dei programmi è più lenta data la presenza del garbage collector.

Nel breve futuro ci si aspetta sempre un numero crescente di oggetti d'uso comune connessi tra loro (i.e. internet of things) e si sente la necessità di metodi sicuri per programmare sistemi integrati. 
Nella ricerca di un linguaggio sicuro con gestione esplicita della memoria Rust sembra essere il miglior candidato.


\section {Stato dell'arte}
Ad oggi differenti linguaggi utilizzano tecniche differenti per i loro meccanismi di sicurezza ma è norma che il linguaggio presenti un sistema di tipi.
Il controllo sui tipi vieta automaticamente qualsiasi azione che coinvolga oggetti di tipo non corrispondente, nonostante ciò non è comunque abbastanza dato che C è tipato e non è sicuro.
Infatti è possibile oltrepassare alcuni limiti imposti dai tipi con i puntatori, la maggior parte dei linguaggi odierni considerati sicuri eliminano questo problema nascondendo i puntatori al programmatore e nel caso in cui fosse presente un'aritmetica dei puntatori di norma non sono \textbf{raw pointer} come in C ma \textbf{smart pointer}, questi ultimi rispetto ai primi presentano delle funzioni controllando l'intervallo degli array o tenendo traccia dell'uso della memoria.
Oltre ad un controllo sui tipi è necessario anche un controllo sugli accessi: in Java esistono classi con più permessi di altre ~\cite{java:privilege}, in Rust è possibile definire una propria politica di autorizzazioni d'accesso ~\cite{rust:auth}, in Python invece non è proprio possibile ~\cite{python:privilege}.

\section{Obiettivi}
L'obiettivo di questo documento è verificare il comportamento di Rust di fronte a tipiche violazioni della sicurezza nei linguaggi di programmazione, a tal fine è stato preso come metro di paragone il linguaggio C, noto per essere vulnerabile, ed è stato scritto del codice non sicuro.
Successivamente è stato scritto del codice che potesse avere effetti simili in Rust osservandone il risultato.

Nel capitolo \ref{chap:security_policy} è presentata la definizione che Rust dà di sicurezza, per analizzare i vari tipi di violazioni di codice è stata fatta una distinzione tra \textbf{memory safety} e \textbf{type safety} (capitoli \ref{chap:memory_safety} e \ref{chap:type_safety}), queste insieme definiscono la sicurezza di un linguaggio ~\cite{nino:security_programming_language}.
La sicurezza in Rust è garantita da ownership e borrowing, nel capitolo \ref{chap:Rust} viene approfondito il sistema che ne è alla base.


\chapter{Security policy} \label{chap:security_policy}

Risulta molto difficile parlare di sicurezza in generale dato che non ne esiste una definizione assoluta ma è un concetto relativo che varia in base a cosa ci interessa proteggere e garantire. 
La sicurezza di un'organizzazione - che essa sia una multinazionale o un singolo individuo - è definita da una \textbf{security policy} ovvero un documento contenente regole, principi e pratiche che determinano come garantire che il sistema si trovi in uno stato sicuro ~\cite{milner:type_polymorphism} e nel quale si definiscono quali azioni i soggetti possano eseguire sugli oggetti. 

È possibile scomporre concettualmente la TCB in \textbf{access control} e \textbf{information flow}, il primo limita chi o cosa possa accedere a quali risorse e il secondo definisce quali operazioni siano corrette o meno in seguito ad un accesso conforme all'access control, di norma il sistema operativo implementa questi controlli via software o hardware e come si vedrà nel capitolo \ref{chap:memory_safety} programmi che sono legali in C potrebbero comunque essere interrotti a runtime ~\cite{nino:security_programming_language}.
In Rust i controlli sono eseguiti per lo più a tempo di compilazione e anche quando un programma viene interrotto a runtime non viene scomodato il sistema operativo (vedere ad esempio il codice nel listato \ref{lst:integeroverflowrs}). 
Questa necessità di implementare la sicurezza nel linguaggio stesso e non rimetterla più nelle mani del sistema operativo è nata dall'avvento di internet e la sempre più grande condivisione di codice potenzialmente pericoloso su macchine diverse.

Per dimostrare delle proprietà di un linguaggio serve una definizione formale della sua \textbf{semantica} ovvero l'insieme delle regole che definiscono il significato di un linguaggio e dei suoi programmi.
Rust non ha una definizione della sua semantica formale (figura \ref{fig:warning}) e quella di sicurezza è poco chiara, un programma è sicuro se rispetta memory safety (capitolo \ref{chap:memory_safety}) e type safety (capitolo \ref{chap:type_safety}) ~\cite[14]{rust:reference} ma la documentazione presenta delle definizioni poco chiare se non addirittura contraddittorie: 

\vspace{5mm}

\begin{Parallel}{0.48\textwidth}{0.48\textwidth}
    \selectlanguage{english}
    \ParallelLText{
        "Rust code is incorrect if it exhibits any of the behaviors in the following list. This includes code within \textcode{unsafe} blocks and \textcode{unsafe} functions. \textcode{unsafe} only means that avoiding undefined behavior is on the programmer; it does not change anything about the fact that Rust programs must never cause undefined behavior." ~\cite[14.3]{rust:reference}
    }
    
    \selectlanguage{italian}
    \ParallelRText{
        "Del codice in Rust non è corretto se presenta almeno uno dei comportamenti in lista. Questo vale anche per codice in blocchi \texttt{unsafe} e funzioni \textcode{unsafe}. \texttt{unsafe} significa solo che evitare undefined behaviour è compito del programmatore; non cambia alcuna garanzia sul fatto che i programmi in Rust non debbano mai causare undefined behaviour." 
    }
    \ParallelPar
\end{Parallel}

\vspace{5mm}

L'uso del termine "unsafe" è causa di confusione dal momento che \colorbox{backcolour}{\texttt{unsafe}} è un costrutto sintattico che consente la scrittura di codice che può causare \textbf{undefined behavior}, per questo si dice che Rust è composto da due "sottolinguaggi": \textit{unsafe Rust} e \textit{safe Rust} in base alla presenza o meno di un blocco \colorbox{backcolour}{\texttt{unsafe}} nel codice, questo costrutto è desiderabile perché permette sia di poter comunicare con librerie in \textit{C} che di avere un accesso più esplicito alla memoria ~\cite[1.2]{rust:rustonomicon}; piuttosto che una definizione formale di undefined behavior si ha una lista in continuo aggiornamento ~\cite[14.3]{rust:reference}, è importante notare che comunque safe Rust presenta del codice in blocchi \textcode{unsafe} scritto dagli sviluppatori.

Nella citazione riportata sono presenti fonti di confusione: nella stessa frase viene detto prima che in un blocco \textcode{unsafe} sia compito del programmatore evitare undefined behavior e subito dopo viene affermato come le garanzie sulla safety siano le stesse di safe Rust, quindi anche l'assenza di undefined behavior. 
Volendo comunque considerare solo l'ultima affermazione, l'esecuzione in un blocco \textcode{unsafe} di uno degli esempi in lista non dovrebbe causare undefined behavior; nel listato \ref{lst:unsafe_raw} si ha un \textbf{raw pointer dereferencing} (presente in lista come dimostrato in figura \ref{fig:warning}): è possibile leggere il valore memorizzato in una locazione di memoria tramite il suo indirizzo come in C.

È ragionevole che questo sia possibile solo in unsafe Rust ma mette in luce come la documentazione sia poco chiara. 

\lstinputlisting[language=Rust]{../code/Unsafe/raw.rs}
\lstinputlisting[caption={Raw pointer dereferencing in un blocco \texttt{unsafe}}, label={lst:unsafe_raw}, numbers=none]{../code/Unsafe/output/rawrs.txt}

\begin{figure}[h!t]
    \centering
    \includegraphics[scale=0.52]{images/warning_undefined_behavior.png}
    \caption{Il raw pointer dereferencing è considerato undefined behavior}
    \label{fig:warning}
\end{figure}

Nonostante la poca chiarezza si prendono come riferimento le seguenti proprietà ~\cite[14]{rust:language} per le quali in del codice safe:

\begin{lemma} \label{lemma:unsafe}
	Non può essere presente codice \textnormal{\textcode{unsafe}}.
\end{lemma}

\begin{lemma} \label{lemma:undef_behaviour}
	Nessun programma genera undefined behaviour.
\end{lemma}

\begin{lemma} \label{lemma:raw_pointer}
	Non è possibile dereferenziare un raw pointer.
\end{lemma}

\begin{lemma} \label{lemma:union}
	Non è possibile accedere ad un campo di un'\textnormal{\textcode{union}} se non per l'inizializzazione. 

	\textnormal{I vari campi in una union condividono la stessa area di memoria, differentemente dalle struct non è possibile capire se un campo sia attivo o meno e accedere ad un campo non inizializzato potrebbe ritornare valori non definiti e causare undefined behavior (listato \ref{lst:unionrs}).}
\end{lemma}

\lstinputlisting[language=Rust]{../code/Unsafe/union.rs}
\lstinputlisting[numbers=none, caption={Accedere al campo di una union.}, label={lst:unionrs}]{../code/Unsafe/output/unionrs.txt}

\chapter{Rust} \label{chap:Rust}

I meccanismi di sicurezza in Rust sono solidi in quanto ben definiti matematicamente.
Un'interpretazione della logica lineare di Girard permette di esprimere formalmente operazioni in termini di consumo di risorse, questa interpretazione è implementata nell'ownership.
Nella sezione \ref{sec:Rust_substruct} è proposta una panoramica sui sistemi substrutturali, ai quali appartiene Rust. 
Inoltre è possibile definire formalmente i lifetime e se ne vedono alcune proprietà nella sezione \ref{sec:Rust_linear}.

\section{Sistemi di tipi substrutturali} \label{sec:Rust_substruct}

I sistemi di tipi \textbf{substrutturali} sono una famiglia di sistemi di tipi (capitolo \ref{chap:type_safety}) dove almeno una delle seguenti proprietà - dette \textbf{strutturali} - non è presente o lo è sotto determinate condizioni, allo stesso modo si parlerà anche di logiche substrutturali.

\begin{lemma}[Exchange] \label{lemma:exchange}
    L'ordine degli elementi all'interno di un'ipotesi o conclusione è irrilevante.
\end{lemma}

\begin{lemma}[Weakening] \label{lemma:weakening}
    L'ipotesi e la conclusione possono essere estese con affermazioni non rilevanti senza alcuna ripercussione. 
\end{lemma}

\begin{lemma}[Contraction] \label{lemma:contraction}
    In ipotesi o conclusione è possibile sostituire due membri con un terzo, a patto che entrambi siano nella stessa espressione e che siano effettivamente unificabili.
\end{lemma}

Un'interpretazione delle logiche e dei sistemi substrutturali permette di ragionare in termini di consumo di risorse, vincolandone l'accesso e tenendo traccia dei cambiamenti di stato della memoria evitando stati non validi. 

In un esempio del 1987 Tony Hoare suppone di rappresentare in logica del primo ordine il fatto di avere una caramella con il predicato \textit{candy} e con  \textit{\$1} il possesso di un dollaro, per esprimere l'atto di compravendita di una caramella possiamo scrivere $ \textit{\$1} \rightarrow \textit{candy} $.

\begin{equation*}
  \begin{prooftree}
    \hypo{\textit{\$1} \rightarrow \textit{candy}}
    \hypo{\textit{\$1}}
    \infer2[modus ponens]{\textit{candy}}
  \end{prooftree}
\end{equation*}

Se ne deduce $ \textit{\$1} \land \textit{candy} $ e si ha una caramella senza aver pagato, si può evitare questo problema con modellazioni differenti della base di conoscenza ma si incorre nel \textit{frame problem} \footnote{In intelligenza artificiale è il problema di dover rappresentare una conoscenza in logica senza ricorrere a numerosi assiomi i quali indicano solo che l'ambiente non cambia arbitrariamente.}. 

\begin{table}[h!t]
    \centering
    \caption{Sistemi di tipi substrutturali.}
    \label{tab:substructural_type_systems}
    \begin{tabular}{c|ccc}
        & \textbf{Exchange} & \textbf{Weakening} & \textbf{Contraction} \\
        \hline
        \textbf{Rilevante} & \cmark & \xmark & \cmark\\
        \textbf{Affine} & \cmark & \cmark & \xmark\\
        \textbf{Lineare} & \cmark & \xmark & \xmark\\
        %\textbf{Ordinato} & \xmark & \xmark & \xmark\\
    \end{tabular}
\end{table}

Nella tabella \ref{tab:substructural_type_systems} è presentata una corrispondenza tra alcuni sistemi substrutturali e le regole in esso valide: in un sistema di tipi rilevante dal momento che non vale la regola di weakening non è possibile avere risorse superflue e ognuna dovrà essere usata almeno una volta. 
La definizione del verbo \textit{usare} è ambigua e dipende dall'implementazione del linguaggio, si può definire un insieme di azioni e quando si afferma di usare una risorsa ci si riferisce all'esecuzione su questa di una delle azioni possibili, in Rust ad esempio sono specificate dalle regole di ownership, per evitare \textbf{double free} (sezione \ref{sec:double_free}) si vieta che due variabili prendano possesso dello stesso oggetto contemporaneamente.

In un sistema affine non è valida la contraction, questo implica che due usi differenti della stessa risorsa non possano essere unificati in uno solo e in un programma si può tradurre con l'impossibilità di liberare due volte la stessa zona di memoria.
Un sistema o una logica lineare ~\cite{girard:linear_logic} è sintesi di uno rilevante e un affine quindi vale solo exchange, ogni risorsa deve essere usata esattamente una volta, in Rust se si usa la stessa variabile più volte si ha un errore invece se non la si usa mai un warning.
Nella sintassi di una logica lineare sono presenti dei qualificatori che marcano una variabile come lineare indicando che debba essere usata una volta.

In un sistema lineare per garantire la non riusabilità di una variabile vengono imposte due invarianti ~\cite{walker:linear_logic}:

\begin{enumerate}
    \item Le variabili lineari sono usate esattamente una volta per ogni cammino nel diagramma di flusso.
    \item Espressioni meno restrittive non possono contenere espressioni più restrittive. 
\end{enumerate}

Il perché la prima invariante sia fondamentale è chiaro, dopotutto è proprio il nostro obiettivo; per la seconda supponiamo di avere un oggetto \texttt{X} non lineare e un suo attributo \texttt{X.y} lineare, sarebbe possibile sfruttare \texttt{X} per usare più volte \texttt{X.y}, si avrebbe in questo modo una violazione della linearità. 

\section{Linearità in Rust} \label{sec:Rust_linear}

Rust presenta un sistema dei tipi lineare e tutte le variabili sono marcate come lineari tranne quelle di tipo primitivo, le invarianti sulla linearità vengono rispettate tramite ownership e borrowing.

In Rust gli oggetti di tipo composto sono lineari e solo a questi si applica l'ownership.
Al momento dell'inizializzazione di un oggetto la sua variabile, se presente, è l'unico owner e un assegnamento ad una seconda variabile fa passare il possesso dalla prima alla seconda: in qualsiasi momento quindi può esserci solo un possessore per ogni oggetto. 

Per i lifetime in Rust valgono tre regole assiomatiche ~\cite{mechpen:misundestand}:

\begin{lemma}[Association] \label{lemma:association}
    Dato un riferimento il suo scope è sottoinsieme del suo lifetime.
    \begin{equation*}
        \textnormal{\textcode{x:\&'a T}} \longrightarrow  scope(x) \subseteq \ 'a
    \end{equation*}
\end{lemma}

\begin{lemma}[Reference] \label{lemma:reference}
    Un lifetime associato ad un riferimento è sottoinsieme dello scope dell'oggetto cui fa riferimento. 
    \begin{equation*}
        \textnormal{\textcode{x:\&'a T = \&y}} \longrightarrow \ 'a \subseteq scope(y)
    \end{equation*}
\end{lemma}

\begin{lemma}[Assignment] \label{lemma:assignment}
    Un lifetime associato ad un riferimento è sottoinsieme del lifetime dell'oggetto cui fa riferimento.
    \begin{equation*}
        \textnormal{\textcode{x:\&'a S = y: \&'b T}} \longrightarrow \ 'a \subseteq \ 'b
    \end{equation*}
\end{lemma}

e ne deriva una quarta regola:

\begin{lemma}[Struct reference] \label{lemma:struct_reference}
    Data una struct \textnormal{\textcode{struct S<'a>\{x:\&'a T\}}} il lifetime associato ad un riferimento di una struct è sottoinsieme del lifetime del membro della struct\footnote{Nel caso in cui dovessero esserci più elementi con lifetime differenti si può considerare il maggiore.}.
    \begin{equation*}
        \textnormal{\textcode{s:\&'b S<'a>}} \longrightarrow \ 'b \subseteq \ 'a
    \end{equation*}
    Dimostrazione: \textnormal{Per \textnormal{\textcode{s:\&'b S<'a>}} esiste un \textcode{y:S<'a>} tale che \textcode{s:\&'b S = \&y} e applicando \ref{lemma:reference} e \ref{lemma:association} si ha} $ 'b \subseteq scope(y) = scope(y.x) \subseteq \ 'a  $.
\end{lemma}

% double reference non la scrivo perché non so neanche se sia legale in Rust

e si hanno delle regole speciali:
\begin{itemize}
    \item Il lifetime speciale \textcode{'static} rappresenta lo scope globale, ogni lifetime è suo sottoinsieme $ 'a \subseteq \ 'static $
    \item La \textbf{coercion} permette di forzare un lifetime più lungo in uno più breve $ \textnormal{\textcode{'a:'b}} \leftrightarrow 'a \subseteq \ 'b $
\end{itemize}

Si parla di \textbf{outliving} quando per una variabile è possibile mantenere il riferimento di un oggetto distrutto. 
Nelle righe 2 e 5 del listato \ref{lst:lifetime_1} si possono applicare rispettivamente le regole \ref{lemma:association} e \ref{lemma:reference} per dedurre $ scope(x) \subseteq \ 'a $ e $ 'a \subseteq scope(y) $, è noto $ scope(y) \subset scope(x) $ quindi il borrow checker interviene.

\lstinputlisting[language=Rust]{../code/Lifetime/life_1.rs}
\lstinputlisting[caption={Outliving e borrow checker.}, label={lst:lifetime_1}, numbers=none]{../code/Lifetime/output/life_1.txt}

Si può ottenere outliving cambiando il tipo di \textcode{y} da \textcode{i32} a \textcode{\&i32} (listato \ref{lst:lifetime_1_1}), così facendo non è possibile applicare \ref{lemma:reference} e vale $ scope(y) \subset scope(x) \subset \ 'a $. 
Un comportamento del genere è inaspettato ma è stato reso possibile per semplificare la definizione di variabili costanti statiche di tipo primitivo ~\cite{git:outliving_static}, i riferimenti ai letterali vengono allocati in memoria di default staticamente e non automaticamente (capitolo \ref{chap:memory_safety}) creando un riferimento con lifetime \textcode{'static}, dunque ogni riferimento ad un dato di tipo primitivo è valido per la durata di tutto il programma.

\lstinputlisting[language=Rust]{../code/Lifetime/life_1_1.rs}
\lstinputlisting[caption={Outliving.}, label={lst:lifetime_1_1}, numbers=none]{../code/Lifetime/output/life_1_1.txt}

In Rust i tipi composti sono costituiti da una struct, nel listato \ref{lst:lifetime_1_2} si può vedere la situazione precedente ma con un tipo non primitivo: nella riga 2 si ha $ scope(x) \subseteq \ 'a $ per \ref{lemma:association} e $ 'a \subseteq scope(y) \subseteq \ 'b$ per \ref{lemma:struct_reference}, è noto $ scope(y) \subset scope(x) $ ed essendoci una contraddizione il borrow checker interviene.  

\lstinputlisting[language=Rust]{../code/Lifetime/life_1_2.rs}
\lstinputlisting[caption={Outliving con tipi composti.}, label={lst:lifetime_1_2}, numbers=none]{../code/Lifetime/output/life_1_2.txt}

Nell'errore in output si parla di \textbf{temporary}: è una variabile anonima inizializzata con il risultato di un'espressione, verrà usata per le successive valutazioni e perderà validità solo al termine del suo scope come qualsiasi variabile. 
A \textcode{Box::new(13)} corrisponde una temporary e quando si tenta di leggerne il valore fuori dal suo scope il compilatore segnala l'errore. 

Negli esempi precedenti i lifetime sono sempre stati inferiti ma nel listato \ref{lst:lifetime_longest} sono esplicitati, si ha:
\begin{gather*}
    scope(rs1) \subseteq \ 'a \subseteq scope(s1) \\
    scope(rs2) \subseteq \ 'a \subseteq scope(s2) \\
    scope(result) \subseteq \ 'a \\
\end{gather*}

che è soddisfatto con $ 'a = scope(result) $.

\lstinputlisting[language=Rust]{../code/Lifetime/life_longest.rs}
\lstinputlisting[caption={Lifetime espliciti.}, label={lst:lifetime_longest}, numbers=none]{../code/Lifetime/output/life_longest.txt}

Quando a seguito di un assegnamento la variabile memorizza un riferimento ad un oggetto si parla di \textbf{shallow copy}, se invece si memorizza il dato per intero si ha una una \textbf{deep copy}. 
In Rust per i dati di tipo primitivo si eseguono sempre deep copy mentre per gli oggetti composti si eseguono di default shallow copy, è comunque possibile copiare l'oggetto nella sua interezza tramite il \textbf{trait} (simile a quello che in Java è un'interfaccia) \textcode{Clone}; questo avviene poiché di un dato di tipo primitivo la dimensione è nota a tempo di compilazione ma non si può dire lo stesso degli oggetti composti. Nel listato \ref{lst:ownership_primitive} \textcode{x} e \textcode{y} puntano a due locazioni differenti.

\lstinputlisting[language=Rust, caption={Ownership con tipi primitivi.}, label={lst:ownership_primitive}]{../code/Ownership/own_prim.rs}

Se con ownership e borrowing l'esecuzione di un programma è molto più rapida e sicura il linguaggio è più verboso e richiede maggior impegno cognitivo da parte del programmatore. 


\chapter{Memory Safety} \label{chap:memory_safety}

Durante l'esecuzione di un programma l'\textbf{address space} di un oggetto ne definisce le locazioni cui potrà accedere, quando nessuna entità accede ad indirizzi fuori dal proprio addess space si parla di \textbf{memory safety}. 
Un linguaggio che garantisce la memory safety dei suoi programmi è memory safe.

Dipendentemente dal tipo di allocazione l'address space è definito a tempo di compilazione o esecuzione, consideriamo i seguenti tipi presenti in C e Rust:

\begin{itemize}
	\item \textbf{Allocazione statica}. Il compilatore memorizza solo ed esclusivamente le variabili globali, lo scope corrisponde a tutto il file.
		Si definiscono tramite un modificatore (in C e Rust è \textcode{static}, da cui il nome) o dichiarandole fuori da ogni funzione.  
    	\item \textbf{Allocazione automatica}. Si usa per variabili locali di tipo primitivo. Una variabile è locale quando dichiarata all'interno di una funzione, l'ordine di esecuzione non è noto a tempo di compilazione e l'allocazione avviene a runtime tramite una struttura dati nota come \textbf{stack} o \textbf{call stack}. 
		Spesso il termine \textit{call stack} viene utilizzato per le sole chiamate di funzione. 
    	\item \textbf{Allocazione dinamica}. L'allocazione dinamica in C è resa esplicita tramite funzioni come \textcode{malloc} che permettono di allocare memoria durante l'esecuzione, si rivela particolarmente utile con oggetti composti dato che non hanno dimensione fissa. 
    		In safe Rust non si hanno funzioni del genere per questioni di sicurezza ma esiste il tipo \textcode{Box}.
		Si fa uso di una struttura dati chiamata \textbf{heap} che ha la particolarità di crescere verso l'alto contrariamente allo stack, in caso di overflow (sezione \ref{sec:buffer_overflow}) uno accede alla memoria dell'altro. 
\end{itemize}

Questo approccio è stato reso popolare dal C ed è oggi adottato da numerosi linguaggi.
In C esiste un ulteriore tipo di allocazione della memoria noto come \textbf{register allocation} che permette di scrivere direttamente su un blocco del processore, non è presente in Rust.

\section{Buffer Overflow} \label{sec:buffer_overflow}
Un \textbf{buffer} è una qualsiasi zona contigua di memoria contenente istanze dello stesso dato, se durante l'esecuzione è possibile accedere ad aree fuori dai limiti imposti si parla di \textbf{buffer overflow}.
Nel listato \ref{lst:stackoverflowc} se ne ha un esempio in C ~\cite[7.5]{stallings:os}: dato che gli array sono posizionati uno dopo l'altro (in ordine LIFO essendo dati allocati su uno stack) si riesce a leggere e scrivere su \textcode{str1}, eludendo così il controllo di uguaglianza.
Nel terzo caso questo controllo viene superato perché si confrontano solo i primi 8 caratteri.
In Rust - conformemente alla proprietà \ref{lemma:undef_behaviour} - questo non è possibile, si veda nel listato \ref{lst:bufofrs} come il linguaggio esegua dei controlli sulle dimensioni degli array, esattamente ciò che la funzione \textcode{gets} non fa. 

\lstinputlisting[language=c]{../code/BufferOverflow/StackOverflow/StackAttack/stackattack.c}
\lstinputlisting[numbers=none]{../code/BufferOverflow/StackOverflow/StackAttack/output/stackattack_1_c.txt}
\lstinputlisting[numbers=none]{../code/BufferOverflow/StackOverflow/StackAttack/output/stackattack_2_c.txt}
\lstinputlisting[caption={Buffer overflow in C}, label={lst:stackoverflowc}, numbers=none]{../code/BufferOverflow/StackOverflow/StackAttack/output/stackattack_3_c.txt}

\lstinputlisting[language=Rust]{../code/BufferOverflow/bufof.rs}
\lstinputlisting[caption=Buffer overflow in Rust, label={lst:bufofrs}, numbers=none]{../code/BufferOverflow/output/bufof_rs.txt}

La pericolosità del buffer overflow è dovuta alla possibilità di eseguire codice arbitrario tramite \textbf{code injection}, nel listato \ref{lst:injection} se ne ha un esempio molto semplice. 
Per la stringa in input non si ha alcun tipo di bound check e si scrive un comando che verrà eseguito da \textcode{system()} con gli stessi permessi con cui si esegue il file. 

\lstinputlisting[language=c]{../code/Injection/inj.c}
\lstinputlisting[caption={Code injection in C}, label={lst:injection}, numbers=none]{../code/Injection/output/inj.txt}

Esistono code injection più sofisticate che possono eseguire codice arbitrario sfruttando le istruzioni in assembly di un programma e la rappresentazione in memoria di un processo ~\cite{stack_smashing_ffp}, si hanno tre regioni:

\begin{itemize}
	\item \textbf{Text}. Contiene le istruzioni da eseguire e dati in sola lettura, quest'area è read-only quindi un tentativo di scrittura è intercettato dal sistema operativo. 
    	\item \textbf{Data}. Contiene dati con scope globale, è l'area di memoria usata dall'allocazione statica.
    	\item \textbf{Stack}. Lo stack sul quale si salvano i dati con allocazione automatica.
		Si può sfruttare il buffer overflow per puntare ad un processo differente ed eseguire codice non desiderato.
\end{itemize}

%%%%%%%%%%%%%%%
\begin{comment}
\section{Stack Overflow}
Quando si chiama una funzione si salva lo \textbf{stack frame} (noto anche come \textbf{activation record} è una zona del call stack contenente dati necessari alla funzione attualmente in esecuzione) e può capitare che chiamate ricorsive facciano entrare il programma in uno stato di non terminazione, Rust individua a tempo di compilazione la ricorsione infinita e segnala l'overflow a tempo di esecuzione. In C l'errore che si vede è dato dal sistema operativo (macOS Catalina 10.15.3) perché con questa ricorsione infinita si prova ad accedere ad un frammento di memoria protetto.

\lstinputlisting[language=c]{../code/BufferOverflow/StackOverflow/Recursion/recursion.c}
\lstinputlisting[caption={Stack overflow ricorsivo in C}, label={lst:recursionc}]{../code/BufferOverflow/StackOverflow/Recursion/output/recursion_c.txt}

\lstinputlisting[language=Rust]{../code/BufferOverflow/StackOverflow/Recursion/recursion.rs}
\lstinputlisting[caption={Stack overflow ricorsivo in Rust}, label={lst:recursionrs}]{../code/BufferOverflow/StackOverflow/Recursion/output/recursion_rs.txt}
\end{comment}
%%%%%%%%%%%%%

\section{Integer Overflow} \label{sec:integer_overflow}
In qualsiasi macchina non astratta si ha memoria finita quindi si può rappresentaare solo un insieme finito di numeri, quando un valore è troppo grande (o piccolo) per essere rappresentato si ha un overflow.
Per risolvere un integer overflow sono due i principali approcci adoperati e si basano su aritmetiche differenti:
\begin{itemize}
    \item \textbf{Modular arithmetic}. Si applica un wrapping ad ogni numero in overflow, dato il valore $ n $ e una memoria a $ m $ bit si memorizza $ w = n \mod m $.
    \item \textbf{Saturation arithmetic}. Si applica un clamp ovvero dati $ min $ e $ max $ - rispettivamente il numero più grande e più piccolo rappresentabile - e un numero $ n $ in memoria si salva
    \begin{equation*}
        c = \begin{cases}
            max & n > max \\
            min & n < min \\
            n  & \text{altrimenti} \\
        \end{cases}
    \end{equation*}
\end{itemize}

L'integer overflow ha in passato causato problemi molto seri: durante il volo inaugurale del lanciatore \textit{Ariane 5} un integer overflow dovuto ad una conversione in intero a 16 bit di un float a 64 bit ha causato una reazione a catena per la quale il razzo ha virato orizzontalmente distruggendosi poco dopo il lancio, il codice scritto in Ada non prevedeva controlli di overflow come esplicitamente richiesto dai progettisti per motivi di efficienza. 
In Rust si hanno due modalità di compilazione: in \textbf{debug mode} si eseguono dei controlli in più rispetto alla \textbf{release mode} tra i quali controlli dinamici per l'integer overflow (listato \ref{lst:integeroverflowrs}) contrariamente al C che applica direttamente wrapping.

Differenti linguaggi adottano differenti approcci: se si può prevedere il valore massimo possibile in un programma allora è in generale facile evitare integer overflow, in caso contrario si possono utilizzare metodi dinamici come in Rust. 

\lstinputlisting[language=Rust]{../code/IntegerOverflow/intof.rs}
\lstinputlisting[caption={Integer overflow in Rust}, label={lst:integeroverflowrs}, numbers=none]{../code/IntegerOverflow/output/intof_rs.txt}

Nel listato \ref{lst:integeroverflowc} si prende un intero come primo argomento e come secondo una stringa, idealmente di lunghezza pari al primo argomento.
Il problema sorge nella conversione da integer a short, inserendo come primo argomento 65536 (uguale a $ 2^{16} $ che non è rappresentabile con i soli 16 bit di uno short) si causa un buffer overflow, combinandone la pericolosità con la difficoltà di rivelamento dell'integer overflow.

\lstinputlisting[language=c]{../code/IntegerOverflow/width1.c}
\lstinputlisting[caption={Integer overflow in C}, label={lst:integeroverflowc}, numbers=none]{../code/IntegerOverflow/output/width1_c.txt}

\section{Double-Free} \label{sec:double_free}
Si ha un double free error ~\cite[10.4.4]{gollmann:computersecurity} quando si prova a liberare più volte la stessa zona di memoria, in Rust non è possibile grazie all'ownership.
In C si può osservare il codice nel listato \ref{lst:doublefree_c}: si immagini di avere un servizio ad iscrizione salvando ogni utente tramite una struct \textcode{User}: \textcode{Guido} libera la propria memoria che, ora disponibile, potrà memorizzare \textcode{Luisa} che si è appena iscritta. 
Il puntatore \textcode{Guido} però ora punta all'account di Luisa e con \textcode{free(Guido)} è proprio l'account di Luisa ad essere eliminato, il risultato è che Luisa non ha più un account e a quello di Carla possono accedere sia Guido che Luisa.

\lstinputlisting[language=c]{../code/DoubleFree/doublefree.c}
\lstinputlisting[caption={Double free in C}, label={lst:doublefree_c}, numbers=none]{../code/DoubleFree/output/doublefree_c.txt}

Il puntatore \textcode{Guido} è anche un \textbf{dangling pointer} (sezione \ref{sec:dangling_reference}).

\section{Dangling References} \label{sec:dangling_reference}
Quando un oggetto viene eliminato senza liberare il suo puntatore si ha un \textbf{dangling pointer} tramite il quale si può accedere a memoria cui non si dovrebbe.

Immaginiamo ora che per vendicarsi Luisa abbia scritto un semplice sistema di messaggistica per leggere la corrispondenza di Guido, la procedura \textcode{send\_message} crea un puntatore di tipo \textcode{Message} con scope solo ed esclusivamente dentro \textcode{send\_message}. 
Luisa tramite un riferimento esplicito alla locazione del messaggio di Guido riesce a leggerlo anche dopo che il puntatore è stato liberato.
Nel listato \ref{lst:dangrefc} per semplicità l'indirizzo viene stampato a schermo e inserito dall'utente, indicato da \textcode{>}.

\lstinputlisting[language=c]{../code/DanglingReference/dangref.c}
\lstinputlisting[caption={Dangling pointer in C}, label={lst:dangrefc}, numbers=none]{../code/DanglingReference/output/dangref_c.txt}

In Rust non è possibile ricreare precisamente l'esempio in C per la proprietà \ref{lemma:raw_pointer}, provando tramite borrowing in ogni caso il borrow checker intercetta l'outliving dei tipi composti, è possibile avere outliving con tipi primitivi come già visto. 
Nel listato \ref{lst:dangrefrs} se ne ha un esempio con le stringhe.
\lstinputlisting[language=Rust]{../code/DanglingReference/dangref.rs}
\lstinputlisting[caption={Dangling pointer in Rust}, label={lst:dangrefrs}, numbers=none]{../code/DanglingReference/output/dangref_rs.txt}

\chapter{Type Safety} \label{chap:type_safety}
Ogni oggetto in matematica ha un \textbf{tipo}, basti pensare al fatto che non è possibile eseguire un'operazione come $ \{13\} \land 10 $ dato che $\{13\}$ è un insieme, $10$ è un numero e $\land$ è un connettivo logico. 
In informatica un tipo è un vincolo che definisce un insieme ben definito di valori che la risorsa di un programma può assumere.

Gli errori riscontrabili in fase di esecuzione possono essere \textbf{trapped} o \textbf{untrapped}, i primi contrariamente ai secondi sono facilmente riconoscibili dato che interrompono l'esecuzione del programma, gli untrapped si rivelano più insidiosi dal momento che potrebbero eseguire codice non voluto.
Un programma che supera il controllo dei tipi è detto ben tipato e un linguaggio in cui nessun programma ben tipato genera errori durante l'esecuzione si dice \textbf{sound}.
In un linguaggio \textbf{safe} nessun programma genera errori untrapped e un linguaggio sound è necessariamente type safe ~\cite{cencia:dispense}.
Una definizione analoga ma meno formale di Milner spesso adottata è la seguente:

\begin{center}
   \textit{well-typed programs cannot “go wrong”} ~\cite{milner:type_polymorphism}
\end{center}

con programmi che "vanno male" si possono intendere programmi non sound o che generano undefined behavior (capitolo \ref{chap:security_policy}).

Si è parlato di controllo dei tipi, il \textbf{type checking} è la verifica dei vincoli imposti dal sistema dei tipi di un linguaggio.
Può avvenire sia a tempo di compilazione che a tempo di esecuzione e si parla rispettivamente di type checking statico/forte e dinamico/debole, un controllo statico è desiderabile per l'ottimizzazione che ne consegue ma non sempre è possibile verificare la correttezza di un programma a tempo di compilazione.
Di norma si usa una combinazione dei due, le costanti come numeri, letterali o booleani sono di solito verificate a tempo di compilazione e gli oggetti di tipo composto a runtime. 

In Java il tempo di \textbf{binding} di un metodo al proprio tipo può essere deciso sia staticamente che dinamicamente.
Con il binding statico si associa un metodo al proprio tipo a tempo di compilazione, è più efficiente e il compilatore ha la garanzia che non vi sarà \textbf{overriding}. 

Quando un metodo viene dichiarato con le parole chiave \textbf{static}, \textbf{private} o \textbf{final} il tempo di binding è statico.
Nel listato \ref{lst:static_binding_java} è dichiarato \textcode{A b = new B()}, dal momento che nella superclasse \textcode{A} è dichiariato \textcode{static print} in output verrà chiamato il metodo \textcode{print} di \textcode{A}.

Se il binding invece è dinamico la scelta su quale metodo usare non ricade sul compilatore ma è eseguita a runtime, nel listato \ref{lst:dynamic_binding_java} il metodo \textcode{print} scelto è quello della sottoclasse \textcode{B} e non della superclasse \textcode{A} per overriding.

\lstinputlisting[language=java]{../code/Java/Static/S.java}
\lstinputlisting[caption={Binding statico dei metodi in Java}, label={lst:static_binding_java}, numbers=none]{../code/Java/Static/output/Sjava.txt}

\lstinputlisting[language=java]{../code/Java/Dynamic/D.java}
\lstinputlisting[caption={Binding dinamic dei metodi in Java}, label={lst:dynamic_binding_java}, numbers=none]{../code/Java/Dynamic/output/Djava.txt}


In un linguaggio tipato l'insieme delle regole che assegna un tipo ad ogni espressione è detto semantica statica o \textbf{sistema dei tipi}.
In ~\cite{security_framework} è presentato un framework per la sicurezza di un linguaggio e in un sistema dei tipi vengono identificate quattro caratteristiche che in base a come vengono implementate permettono di definire un linguaggio sicuro.
Sono \textbf{type safety}, \textbf{type casting}, \textbf{type initialization} e \textbf{immutability}, la definizione della prima è stata già data e nel resto del capitolo si vedranno nello specifico le altre tre.


\section{Type casting}
Quando si esegue un'operazione tra oggetti di tipo differente può rivelarsi necessaria una conversione di tipo (type casting) che può essere esplicita o implicita, nel secondo caso si parla di \textbf{coercion}.
Tipicamente i linguaggi con type checking forte eseguono pochi casting impliciti e quelli con type checking dinamico molti.
Rust è fortemente tipato e non c'è coercion, C è debolmente tipato e presenta conversione implicita.   

\lstinputlisting[language=c]{../code/TypeConversion/coercion.c}
\lstinputlisting[caption={Casting implicito in C}, label={lst:coercionc}, numbers=none]{../code/TypeConversion/output/coercion_c}

\lstinputlisting[language=Rust]{../code/TypeConversion/coercion.rs}
\lstinputlisting[caption={Casting in Rust}, label={lst:coercionrs}, numbers=none]{../code/TypeConversion/output/coercion_rs}

Rust non ha casting implicito perché può portare ad undefined behavior (proprietà \ref{lemma:undef_behaviour}), un esempio di questa vulnerabilità è un bug del 2002 nel sistema operativo FreeBSD per cui in alcune chiamate di sistema si assumeva a priori che il valore in input fosse un intero positivo nonostante nella definizione della funzione il tipo fosse \textcode{int}.
I programmatori data l'assunzione fatta non eseguivano boundary check, questo valore veniva poi passato a \textcode{memcpy()} che prende un \textcode{unsigned int} e a causa della coercion un valore come $ -1 $ veniva convertito in $ 2^{32}-1 $, valore che non avrebbe superato il boundary check.
Inserendo numeri negativi abbastanza grandi era possibile copiare una porzione di memoria riservata al kernel ~\cite{freeBSD_vulnerability}.
Per chiarezza nel listato \ref{lst:freebsd} è stato riproposto del codice a grandi linee simile, il problema è la conversione di \texttt{maxlen} che supera il controllo a riga 11 e viene convertita da intero a intero positivo a riga 12. 

\lstinputlisting[language=c,label={lst:freebsd}]{../code/Unsafe/FreeBSD.c} 

\section{Type initialization} \label{sec:type_initialization}
La dichiarazione di una variabile in C le assegna un address space ma non c'è inizializzazione, il valore della variabile sarà spesso privo di significato o addirittura illegibile poiché corrisponde al dato inserito in quella stessa locazione da un processo passato e riconvertito nel tipo della nuova variabile.

Ad oggi un comportamento del genere è un caso raro e di norma ad una variabile appena dichiarata viene assegnato un valore di default, ad esempio $ 0 $ per i numeri, la stringa vuota per le stringhe e \textcode{NULL} per gli oggetti.

Il valore \textcode{NULL} fu introdotto da Tony Hoare nel 1964 e nel 2009 lui stesso lo definì il suo errore da un miliardo di dollari ~\cite{hoare:billion_dollar_mistake} perché ha portato a numerose sviste ed errori da parte dei programmatori: in C compilando con \textit{GCC} un puntatore a \textcode{NULL} punta a una locazione $ 0 $ riservata (listato \ref{lst:nullreferencec}) e la sua dereferenza causa l'interruzione del programma. 

\lstinputlisting[language=c]{../code/NullPointer/null.c}
\lstinputlisting[caption={Null reference in C}, label={lst:nullreferencec}, numbers=none]{../code/NullPointer/output/null_c.txt}

In Rust non esiste \textcode{NULL} ma si ha il tipo polimorfo \textcode{Option<T>} che può assumere i valori \textcode{Some<T>} o \textcode{None}. 
Nel listato \ref{lst:nullreferencers} si può vedere come un \texttt{Box<i32>} senza alcun valore punti ad un \textcode{None} di tipo \textcode{Option<Box<i32>{}>} e non ad un valore speciale \textcode{NULL}, il quale si colloca meno coerentemente nel sistema dei tipi.

\lstinputlisting[language=Rust]{../code/NullPointer/null.rs}
\lstinputlisting[caption={Null reference in Rust}, label={lst:nullreferencers}, numbers=none]{../code/NullPointer/output/null_rs.txt}

\section{Immutability}
Un oggetto è immutabile quando durante l'esecuzione di un programma non può essere modificato, in Rust ogni oggetto è di default immutabile ma si possono definire esplicitamente oggetti il cui valore è modificabile tramite la parola chiave \textcode{mut}, questa scelta è coerente con il principio di least privilege.
Le costanti invece sono definite tramite la parola chiave \textcode{const} al posto del \textcode{let}, una costante deve essere nota a tempo di compilazione quindi è necessario indicarne esplicitamente il tipo e il valore, quest'ultimo deve essere un'espressione costante e non il risultato a runtime della valutazione di qualche espressione.
È possibile definire una costante in qualsiasi parte del codice ma il lifetime sarà sempre \textcode{'static}, non è possibile definire una costante \textcode{mut} ~\cite[3.1]{rust:language}.

In C non c'è una vera e propria immutabilità, tramite il modificatore \textcode{const} è possibile definire delle costanti che dovrebbero essere non modificabili, rimane comunque possibile dereferenziarle e tramite un puntatore modificarne il valore, l'immodificabilità assume particolare rilievo in programmi concorrenti. 
Nel listato \ref{lst:concurrencyc} abbiamo:
\begin{enumerate}
    \item \textcode{Misc}. Una struct composta da un intero, il cui valore non è rilevante, e un puntatore a un intero nel quale verrà salvato l'indirizzo di \textcode{accum}. 
    \item \textcode{accum}. Una variabile globale costante, il segmento in cui verrà allocata dipende dal compilatore ad esempio usando \textit{GCC} è salvata nel text segment del processo insieme al codice, in ogni caso è un'area in sola lettura.
    \item \textcode{accum\_mutex}.Un \textbf{mutex} o \textbf{lock} è un meccanismo di sincronizzazione per imporre la mutua esclusione ed evitare \textbf{race condition}, garantisce quindi che la stessa risorsa non venga modificata da più thread contemporaneamente.
    Il possesso e il rilascio sono effettuati mediante le due funzioni di lock e unlock.
    \item \texttt{ths}. Un array di 20 thread ovvero sottoprocessi eseguiti parallelamente possibilmente condividendo delle risorse.
    Tramite la chiamata a \textcode{pthread\_join()} si attende il termine del thread in input memorizzandone il risultato di ritorno in \textcode{ret}. 
\end{enumerate}

L'esecuzione del programma è interrotta dal sistema operativo perché \textcode{accum} è read-only ma in C non c'è alcun controllo.

\lstinputlisting[language=c]{../code/Concurrency/thread.c}
\lstinputlisting[caption={Costanti e thread in C}, label={lst:concurrencyc}, numbers=none]{../code/Concurrency/output/concurrency_c.txt}

Il programma nel listato \ref{lst:concurrencyrs} funziona perfettamente, in safe Rust non c'è il pericolo che un valore immutabile venga modificato da un riferimento perché per la proprietà \ref{lemma:raw_pointer} non è possibile dereferenziare un puntatore, vale la pena però notare che in tutto il programma non compaia mai il modificatore \textcode{mut}. La funzione \textcode{thread::spawn()} prende in input una \textbf{closure}, è come una funzione anonima in Java e all'interno delle doppie pipe \textcode{||} si inseriscono i parametri in input, in questo caso nessuno. 
La parola chiave \textcode{move} dà alla closure l'ownership delle variabili che usa evitando così che un thread (\textcode{main} compreso) modifichi una risorsa usata da un altro oggetto, solo una variabile per volta potrà avere il possesso della risorsa in questione, si garantisce la mutua esclusione e si evitano race condition a tempo di compilazione ~\cite[5.6]{rust:language_2}. 
Per la sincronizzazione tra thread si utilizzano le funzioni \colorbox{backcolour}{\texttt{channel}}. 

\lstinputlisting[language=Rust]{../code/Concurrency/thread.rs}
\lstinputlisting[caption={Concorrenza in Rust}, label={lst:concurrencyrs}, numbers=none]{../code/Concurrency/output/concurrency_rs.txt}

\section{Rapporto con Memory Safety}
Type safety e memory safety sono strettamente collegate tanto che a volte risulta davvero difficile distinguere tra le due e alcune vulnerabilità violano entrambe, ad esempio nel listato \ref{lst:lilliputc} si alloca un array di \textcode{short} ($ \SI{2}{\byte} $) sullo stack, considerando che il computer su cui ho eseguito il programma monta un processore \textit{Intel} (little endian quindi la cifra più a destra è la meno significativa) si ha la seguente rappresentazione in memoria.

\begin{table}[H]
	\label{fig:mem_type_stack}
	\centering
	\begin{tabular}{|c|c|}
		\hline
		\texttt{1} & \texttt{1000000000000000} \\
		\hline 
		\texttt{0} & \texttt{0000000000000000} \\
		\hline
	\end{tabular}
\end{table}

il puntatore \texttt{p} punta al primo elemento ma essendo \textcode{int} legge $ \SI{4}{\byte} $  
\[
\texttt{00000000000000001000000000000000} \\
\]
che in decimale equivale a $ 2^{16} = 65536 $. La causa di questa confusione sia la lettura di un solo oggetto da $\SI{4}{\byte} $ anziché due oggetti da 2, questo avviene a causa della rappresentazione di due tipi differenti e del casting che C permette contrariamente a Rust.

\lstinputlisting[language=c]{../code/TypeSafety/Lilliput/lilliput.c}
\lstinputlisting[caption={Type confusion in C}, label={lst:lilliputc}, numbers=none]{../code/TypeSafety/Lilliput/output/lilliput_c.txt}

%In Rust non si può proprio puntare ad una variabile con un tipo differente da quello della variabile stessa.
%\lstinputlisting[language=Rust]{../code/TypeSafety/Lilliput/lilliput.rs}
%\lstinputlisting[caption={Type confusion in Rust}, label={lst:lilliputrs}]{../code/TypeSafety/Lilliput/output/lilliput_rs.txt}


\chapter{Conclusioni}
C è estremamente popolare e vulnerabile, la maggior parte degli oggetti che usiamo ogni giorno presentano software scritto in C ed è fondamentale trovare un linguaggio sicuro che prenda il suo posto, Rust si propone come suo erede.
Eliminando la necessità di gestire la memoria ad un livello tanto basso come nel C viene radicalmente diminuito l'errore umano, affinché il linguaggio però sia adatto a sistemi integrati è da evitare la presenza di un garbage collector e Rust riesce a garantire la sicurezza dei suoi programmi grazie ai meccanismi di ownership e borrowing. 

In questo documento è stato definito cosa sia la sicurezza per Rust dato che non ne esiste una definizione assoluta, alcuni comportamenti che potrebbero sembrare non sicuri in realtà potrebbero essere desiderabili in alcuni contesti.
I meccanismi su cui Rust basa la sua sicurezza sono ownership e borrowing, questi implementano un'interpretazione della logica lineare di Girard per la quale è possibile ragionare in termini di consumo di risorse.
Questo formalismo dona coerenza a Rust e permette di verificarne alcune proprietà, data una definizione matematica delle proprietà dei lifetime è stato possibile analizzarne il comportamento.

La sicurezza di un linguaggio è spesso divisa in memory safety e type safety, nonostante la differenza sia labile, è stato scritto del codice non sicuro in C e un corrispettivo in Rust, i risultati sono positivi e Rust non è vulnerabile a quelli che sono alcuni tra i più classici attacchi.
Questo non vuol dire che Rust sia necessariamente sicuro, i linguaggi di programmazione vengono perfezionati e corretti nel tempo, rimane il fatto che Rust sia più sicuro di C e in un periodo storico in cui facciamo quasi completamente affidamento sul software che ci circonda è fondamentale scongiurare il più possibile l'insorgenza di vulnerabilità. 

Per quanto l'interesse sia grande è da capire se Rust possa effettivamente sostituire C, il suo punto più debole rimane la difficoltà d'apprendimento.


\backmatter

% bibliography
\cleardoublepage
\phantomsection
%\addcontentsline{toc}{chapter}{\bibname}
\bibliographystyle{sapthesis} % BibTeX style
%\bibliography{bibliography} % BibTeX database without .bib extension
\bibliography{main}{}

\end{document}
